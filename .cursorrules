Техническое задание: Bybit Dual-Market Trading Bot
Обзор проекта
Цель: Создать автоматический торговый бот на Python, который мониторит спот-рынок и фьючерсы Bybit одновременно, отслеживает совпадение повышения цены на 5% и Open Interest на 5% за последние 5 минут, и автоматически выполняет сделки с take-profit 2%.
Технологии: Python 3.8+, pybit, WebSocket, threading, pandas, sqlite3
Архитектура: Многопоточное приложение с dual-market мониторингом и автоматическим исполнением ордеров
Структура проекта
bybit_trading_bot/
│
├── main.py                     # Точка входа в приложение
├── config/
│   ├── __init__.py
│   ├── settings.py             # Настройки бота и API
│   └── .env                    # API ключи (создается пользователем)
│
├── core/
│   ├── __init__.py
│   ├── market_monitor.py       # Основной класс мониторинга рынков
│   ├── symbol_mapper.py        # Сопоставление спот/фьючерс пар
│   ├── data_processor.py       # Обработка и анализ данных
│   └── order_manager.py        # Управление торговыми ордерами
│
├── handlers/
│   ├── __init__.py
│   ├── websocket_handler.py    # Обработка WebSocket соединений
│   ├── spot_handler.py         # Обработчик спот-рынка
│   └── futures_handler.py      # Обработчик фьючерсного рынка
│
├── utils/
│   ├── __init__.py
│   ├── logger.py               # Система логирования
│   ├── db_manager.py          # Управление базой данных
│   └── helpers.py             # Вспомогательные функции
│
├── storage/
│   ├── __init__.py
│   └── database.sqlite        # SQLite база данных (создается автоматически)
│
├── tests/
│   ├── __init__.py
│   ├── test_market_monitor.py
│   ├── test_symbol_mapper.py
│   └── test_order_manager.py
│
├── requirements.txt           # Зависимости Python
├── README.md                  # Документация по установке и использованию
├── .cursorrules              # Правила для Cursor AI
└── .gitignore                # Исключения Git

Функциональные требования
1. Инициализация и настройка
•	[x] Загрузка API ключей из .env файла
•	[x] Проверка подключения к Bybit API (спот и фьючерсы)
•	[x] Создание маппинга общих торговых пар между спот и фьючерсным рынками
•	[x] Инициализация SQLite базы данных для хранения данных
•	[x] Настройка системы логирования
2. Мониторинг спот-рынка
•	[x] WebSocket подключение для получения ticker данных в реальном времени
•	[x] Обработка обновлений цен для всех отслеживаемых пар
•	[x] Сохранение ценовых данных с временными метками
•	[x] Расчет изменения цены за последние 5 минут
•	[x] Обнаружение роста цены на 5% и более
3. Мониторинг фьючерсного рынка
•	[x] Периодический опрос Open Interest через HTTP API
•	[x] Обработка данных OI с интервалами 5 минут
•	[x] Сохранение исторических данных OI
•	[x] Расчет изменения OI за последние 5 минут
•	[x] Обнаружение роста OI на 5% и более
4. Анализ условий и торговля
•	[x] Синхронизация данных спот и фьючерсного рынков
•	[x] Проверка одновременного выполнения обоих условий (+5% цена И +5% OI)
•	[x] Автоматическое размещение buy ордеров на спот-рынке
•	[x] Установка take-profit на 2% выше цены входа
•	[x] Автоматическое закрытие позиций при достижении TP
5. Управление рисками
•	[x] Контроль размера позиций (настраиваемый процент от депозита)
•	[x] Максимальное количество одновременных позиций
•	[x] Защита от повторных сигналов для одной пары
•	[x] Emergency stop функция
•	[x] Мониторинг API лимитов
6. Логирование и мониторинг
•	[x] Детальное логирование всех операций
•	[x] Сохранение истории сделок в базе данных
•	[x] Уведомления о важных событиях
•	[x] Статистика производительности бота
•	[x] Веб-интерфейс для мониторинга (опционально)
Технические требования
1. Зависимости Python
pybit>=5.7.0
pandas>=2.0.0
sqlite3 (встроенный)
python-dotenv>=1.0.0
websocket-client>=1.6.0
requests>=2.31.0
threading (встроенный)
datetime (встроенный)
logging (встроенный)
json (встроенный)
time (встроенный)

2. Конфигурация API
# .env файл (пример)
BYBIT_API_KEY=your_api_key_here
BYBIT_API_SECRET=your_api_secret_here
BYBIT_TESTNET=True  # False для продакшена

# Настройки бота
MAX_POSITION_SIZE_PERCENT=1.0  # 1% от депозита на сделку
MAX_SIMULTANEOUS_POSITIONS=5
PRICE_CHANGE_THRESHOLD=5.0  # 5%
OI_CHANGE_THRESHOLD=5.0     # 5%
TAKE_PROFIT_PERCENT=2.0     # 2%
MONITORING_INTERVAL=60      # секунды для проверки OI

3. Структура базы данных
-- Таблица торговых пар
CREATE TABLE symbols (
    id INTEGER PRIMARY KEY,
    spot_symbol TEXT NOT NULL,
    futures_symbol TEXT NOT NULL,
    is_active BOOLEAN DEFAULT 1,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Таблица ценовых данных
CREATE TABLE price_data (
    id INTEGER PRIMARY KEY,
    symbol_id INTEGER,
    price REAL NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    FOREIGN KEY (symbol_id) REFERENCES symbols (id)
);

-- Таблица данных Open Interest
CREATE TABLE oi_data (
    id INTEGER PRIMARY KEY,
    symbol_id INTEGER,
    open_interest REAL NOT NULL,
    timestamp TIMESTAMP NOT NULL,
    FOREIGN KEY (symbol_id) REFERENCES symbols (id)
);

-- Таблица сделок
CREATE TABLE trades (
    id INTEGER PRIMARY KEY,
    symbol_id INTEGER,
    order_id TEXT,
    side TEXT,
    quantity REAL,
    entry_price REAL,
    take_profit_price REAL,
    status TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    closed_at TIMESTAMP,
    pnl REAL,
    FOREIGN KEY (symbol_id) REFERENCES symbols (id)
);

-- Таблица сигналов
CREATE TABLE signals (
    id INTEGER PRIMARY KEY,
    symbol_id INTEGER,
    price_change_percent REAL,
    oi_change_percent REAL,
    action_taken TEXT,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (symbol_id) REFERENCES symbols (id)
);

Детальные спецификации классов
1. MarketMonitor (core/market_monitor.py)
class MarketMonitor:
    """Основной класс для мониторинга двух рынков"""
    
    def __init__(self, config):
        # Инициализация API клиентов, WebSocket, базы данных
        
    def start_monitoring(self):
        # Запуск всех потоков мониторинга
        
    def stop_monitoring(self):
        # Корректная остановка всех процессов
        
    def check_trading_conditions(self, symbol_id):
        # Проверка условий: цена +5% И OI +5%
        
    def execute_trade_signal(self, symbol_id, price_change, oi_change):
        # Выполнение торговой сделки при срабатывании сигнала

2. SymbolMapper (core/symbol_mapper.py)
class SymbolMapper:
    """Сопоставление спот и фьючерсных пар"""
    
    def get_common_symbols(self):
        # Получение списка общих торговых пар
        
    def create_symbol_mapping(self):
        # Создание маппинга и сохранение в БД
        
    def is_symbol_active(self, spot_symbol):
        # Проверка активности торговой пары

3. WebSocketHandler (handlers/websocket_handler.py)
class WebSocketHandler:
    """Обработка WebSocket соединений для спот-рынка"""
    
    def connect_to_spot_stream(self, symbols):
        # Подключение к потоку спот-данных
        
    def handle_ticker_update(self, message):
        # Обработка обновлений тикера
        
    def reconnect_on_failure(self):
        # Переподключение при разрыве соединения

4. OrderManager (core/order_manager.py)
class OrderManager:
    """Управление торговыми ордерами"""
    
    def place_spot_order(self, symbol, side, quantity, take_profit):
        # Размещение спот-ордера с take-profit
        
    def monitor_open_positions(self):
        # Мониторинг открытых позиций
        
    def close_position(self, order_id):
        # Закрытие позиции
        
    def calculate_position_size(self, symbol, current_price):
        # Расчет размера позиции

Алгоритм работы бота
1. Инициализация
1.	Загрузка конфигурации из .env файла
2.	Проверка API ключей и подключения к Bybit
3.	Получение списков спот и фьючерсных пар
4.	Создание маппинга общих символов (~200 пар)
5.	Инициализация базы данных SQLite
6.	Настройка логирования
2. Запуск мониторинга
1.	Поток 1: WebSocket для спот-данных
o	Подписка на ticker stream для всех символов
o	Обработка обновлений цен в реальном времени
o	Сохранение данных в БД с временными метками
2.	Поток 2: HTTP polling для Open Interest
o	Запрос OI данных каждые 60 секунд
o	Получение 5-минутных интервалов
o	Сохранение в БД и расчет изменений
3.	Поток 3: Анализ условий
o	Проверка каждого символа на соответствие критериям
o	Расчет изменений за последние 5 минут
o	Генерация торговых сигналов
4.	Поток 4: Исполнение ордеров
o	Размещение buy ордеров при срабатывании сигналов
o	Мониторинг открытых позиций
o	Автоматическое закрытие по take-profit
3. Логика торгового сигнала
def check_signal_conditions(symbol_id):
    # 1. Получить данные за последние 5 минут
    price_data = get_recent_price_data(symbol_id, minutes=5)
    oi_data = get_recent_oi_data(symbol_id, minutes=5)
    
    # 2. Рассчитать изменения
    price_change = calculate_percentage_change(price_data)
    oi_change = calculate_percentage_change(oi_data)
    
    # 3. Проверить условия
    if price_change >= 5.0 and oi_change >= 5.0:
        return True, price_change, oi_change
    
    return False, price_change, oi_change

4. Размещение ордера
def execute_buy_order(symbol, current_price):
    # 1. Рассчитать размер позиции (1% от депозита)
    position_size = calculate_position_size(current_price)
    
    # 2. Установить take-profit (+2%)
    take_profit_price = current_price * 1.02
    
    # 3. Разместить ордер
    order = session.place_order(
        category="spot",
        symbol=symbol,
        side="Buy",
        orderType="Market",
        qty=str(position_size),
        takeProfit=str(take_profit_price),
        tpOrderType="Market"
    )
    
    # 4. Сохранить в БД
    save_trade_to_db(order)
    
    return order

Требования к реализации
1. Обработка ошибок
•	Все API вызовы должны быть обернуты в try/except блоки
•	Логирование всех ошибок с подробными сообщениями
•	Автоматическое переподключение WebSocket при разрыве
•	Graceful degradation при недоступности API
2. Производительность
•	Эффективное использование threading для параллельной обработки
•	Оптимизация SQL запросов с индексами
•	Кэширование часто используемых данных
•	Контроль потребления памяти
3. Безопасность
•	API ключи только в .env файле (не в коде)
•	Валидация всех входящих данных
•	Защита от SQL инъекций через параметризованные запросы
•	Контроль лимитов API запросов
4. Логирование
# Уровни логирования:
# DEBUG: Детальная информация о работе
# INFO: Общая информация (сигналы, ордера)
# WARNING: Предупреждения (лимиты API, задержки)
# ERROR: Ошибки (неудачные ордера, проблемы соединения)
# CRITICAL: Критические ошибки (остановка бота)

logger.info(f"🚀 SIGNAL: {symbol} - Price: +{price_change:.2f}%, OI: +{oi_change:.2f}%")
logger.info(f"✅ ORDER PLACED: {symbol} - Qty: {qty}, TP: {tp_price}")
logger.error(f"❌ ORDER FAILED: {symbol} - Error: {error}")

5. Конфигурация
Все параметры должны быть настраиваемыми:
•	Пороги срабатывания (5% цена, 5% OI)
•	Размер позиций (1% от депозита)
•	Take-profit уровень (2%)
•	Интервалы мониторинга (60 секунд для OI)
•	Максимальное количество позиций
Критерии приемки
1. Функциональность
•	[x] Бот успешно подключается к Bybit API (спот и фьючерсы)
•	[x] Создается корректный маппинг торговых пар (не менее 100 пар)
•	[x] WebSocket получает данные цен в реальном времени
•	[x] HTTP API получает данные Open Interest каждую минуту
•	[x] Правильно рассчитываются изменения за 5 минут
•	[x] Сигналы генерируются при соблюдении обоих условий
•	[x] Ордера размещаются с корректными параметрами
•	[x] Take-profit срабатывает автоматически
2. Надежность
•	[x] Бот работает непрерывно минимум 24 часа без сбоев
•	[x] Автоматическое восстановление WebSocket соединений
•	[x] Корректная обработка всех типов ошибок API
•	[x] Валидация данных перед размещением ордеров
•	[x] Защита от дублирования сигналов
3. Производительность
•	[x] Обработка обновлений цен с задержкой менее 1 секунды
•	[x] Размещение ордеров в течение 5 секунд после сигнала
•	[x] Потребление RAM не более 500MB
•	[x] CPU нагрузка не более 10% в среднем
4. Документация
•	[x] README с пошаговыми инструкциями по установке
•	[x] Документация API и конфигурации
•	[x] Примеры конфигурационных файлов
•	[x] Описание алгоритма работы
Инструкции для Cursor AI
Подход к разработке:
1.	Начните с core/market_monitor.py - основного класса
2.	Реализуйте поэтапно: сначала мониторинг, затем торговлю
3.	Тестируйте каждый модуль отдельно перед интеграцией
4.	Используйте testnet для всех тестов
Стиль кода:
•	Следуйте PEP 8 стандартам Python
•	Используйте type hints для всех функций
•	Добавляйте docstrings для всех классов и методов
•	Комментируйте сложную бизнес-логику
Приоритеты реализации:
1.	Высокий: Мониторинг данных, генерация сигналов
2.	Средний: Размещение ордеров, управление позициями
3.	Низкий: Веб-интерфейс, расширенная аналитика
Особенности Bybit API:
•	Используйте category="spot" для спот-рынка
•	Используйте category="linear" для USDT фьючерсов
•	Open Interest API: get_open_interest() с интервалом "5min"
•	WebSocket: ticker stream для real-time цен
•	Rate limits: 600 запросов/5сек, 500 WebSocket подключений/5мин
Этот документ должен предоставить Cursor AI все необходимые детали для создания полноценного торгового бота.
